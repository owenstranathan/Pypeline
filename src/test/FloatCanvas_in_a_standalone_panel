# CreateRadialGradientBrush (self, xo, yo, xc, yc, radius, oColor, cColor)
# Canvas.AddCircle(xy, D, LineWidth = lw, LineColor = colors[cl], FillColor = colors[cf])
# Canvas.AddText("Circle # %i"%(i), xy, Size = 12, BackgroundColor = None, Position = "cc")

import wx
import numpy as N
from wx.lib.floatcanvas import NavCanvas, FloatCanvas, GUIMode, Resources

#############################################################################
class OpacityMixin:

    # Method to set the color and alpha value of a brush
    def SetBrush(self, FillColor, FillStyle):
        "Like standard SetBrush except that FillStyle is an integer giving\
        opacity , where 0<=opacity<=255"

        opacity = FillStyle

        color = wx.Colour()
        color.SetFromName(FillColor)
        # all wx.Colors are given as 3 values of red, green, blue intensities
        red, green, blue = color.Get()
        c = wx.Colour(red, green, blue, opacity)
        self.Brush = wx.Brush(color)


class AlphaCircle(OpacityMixin, FloatCanvas.Circle):
    def __init__(self, XY, Diameter, **kwargs):
        FloatCanvas.Circle.__init__(self, XY, Diameter, **kwargs)
        self.XY = self.Center

    def _Draw(self, dc, WorldToPixel, ScaleWorldToPixel, HTdc=None):
        gc = wx.GraphicsContext.Create(dc)
        (XY, WH) = self.SetUpDraw(gc, WorldToPixel, ScaleWorldToPixel, HTdc)

        path = gc.CreatePath()
        center = XY
        radius = WH[0] * 0.5

        path.AddCircle(center[0], center[1], radius)

        gc.PushState()
        gc.SetPen(wx.Pen(self.LineColor, self.LineWidth))
        gc.SetBrush(self.Brush)
        gc.DrawPath(path)
        gc.PopState()

class SmoothArrowLine(FloatCanvas.PointsObjectMixin, FloatCanvas.LineOnlyMixin, FloatCanvas.DrawObject):
    """
    ArrowLine class definition.

    API definition::

        ArrowLine(Points, # coords of points
                  LineColor = "Black",
                  LineStyle = "Solid",
                  LineWidth    = 1,
                  ArrowHeadSize = 4, # in pixels
                  ArrowHeadAngle = 45,
                  InForeground = False):


    It will draw a set of arrows from point to point.

    It takes a list of 2-tuples, or a NX2 NumPy Float array
    of point coordinates.


    """

    def __init__(self,
                 Points,
                 LineColor = "Black",
                 LineStyle = "Solid",
                 LineWidth    = 1, # pixels
                 ArrowHeadSize = 8, # pixels
                 ArrowHeadAngle = 30, # degrees
                 InForeground = False):

        FloatCanvas.DrawObject.__init__(self, InForeground)

        self.Points = N.asarray(Points,N.float)
        self.Points.shape = (-1,2) # Make sure it is a NX2 array, even if there is only one point
        self.ArrowHeadSize = ArrowHeadSize
        self.ArrowHeadAngle = float(ArrowHeadAngle)

        self.CalcArrowPoints()
        self.CalcBoundingBox()

        self.LineColor = LineColor
        self.LineStyle = LineStyle
        self.LineWidth = LineWidth

        self.SetPen(LineColor,LineStyle,LineWidth)

        self.HitLineWidth = max(LineWidth,self.MinHitLineWidth)

    def CalcArrowPoints(self):
        S = self.ArrowHeadSize
        phi = self.ArrowHeadAngle * N.pi / 360
        Points = self.Points
        n = Points.shape[0]
        self.ArrowPoints = N.zeros((n-1, 3, 2), N.float)
        for i in xrange(n-1):
            dx, dy = self.Points[i] - self.Points[i+1]
            theta = N.arctan2(dy, dx)
            AP = N.array( (
                            (N.cos(theta - phi), -N.sin(theta-phi)),
                            (0,0),
                            (N.cos(theta + phi), -N.sin(theta + phi))
                            ),
                          N.float )
            self.ArrowPoints[i,:,:] = AP
        self.ArrowPoints *= S

    def _Draw(self, dc , WorldToPixel, ScaleWorldToPixel, HTdc=None):
        Points = WorldToPixel(self.Points)
        ArrowPoints = Points[1:,N.newaxis,:] + self.ArrowPoints
        dc.SetPen(self.Pen)
        dc.DrawLines(Points)
        GC = wx.GraphicsContext.Create(dc)
        GC.SetPen(self.Pen)
        GC.DrawLines(Points)
        for arrow in ArrowPoints:
                GC.DrawLines(arrow)

class DrawTheTrueTrue(wx.Panel):


    def __init__(self, parent):
        super(DrawTheTrueTrue, self).__init__(parent)

        # Init style and color
        self.SetBackgroundColour('WHITE')
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

       # Deprecated but whatevs
        self.firstClick = False
        self.lines = []
        self.node_pos_list = []
        self.redo_lines = []
        self.redo_nodes = []
        self.counter = 0

    #######################################################################################################
        # Init canvas
        self.Canvas = FloatCanvas.FloatCanvas(self)

        ##BIND MOUSE EVENTS
        self.Canvas.Bind(FloatCanvas.EVT_LEFT_DOWN, self.onLeftDown)
        self.Canvas.Bind(FloatCanvas.EVT_MOTION, self.onMouseMove)
        self.Canvas.Bind(FloatCanvas.EVT_MOUSEWHEEL, self.onWheel)

        ##BIND KEYBOARD EVENTS
        self.Canvas.Bind(wx.EVT_KEY_DOWN, self.onKeyDown)

        # InitAll() sets everything in the Canvas to default state.
        # It can be used to reset the Canvas
        self.Canvas.InitAll()

        # This is all from Navcanvas, to keep funtionality, I'll take these calls to GUIMode and bind them
        # to the actual GUI Toolbar, later...
        self.Modes = [("Pointer",  GUIMode.GUIMouse(),   Resources.getPointerBitmap()),
                      ("Zoom In",  GUIMode.GUIZoomIn(),  Resources.getMagPlusBitmap()),
                      ("Zoom Out", GUIMode.GUIZoomOut(), Resources.getMagMinusBitmap()),
                      ("Pan",      GUIMode.GUIMove(),    Resources.getHandBitmap()),
                      ]

        self.BuildToolbar()

        ## Create the vertical sizer for the toolbar and Panel
        # Remember that verticial means the widgets will stack vertically
        # You need to have a sizer for all widgets in the GUI
        # In general the hierarchy needs to be followed container --> widget
        box_sizer = wx.BoxSizer(wx.VERTICAL)
        box_sizer.Add(self.ToolBar, 0, wx.ALL | wx.ALIGN_LEFT | wx.GROW, 4)

        # second parameter refers to "proportionality" so the toolbar to drawing area will be 1:6
        box_sizer.Add(self.Canvas, 1, wx.GROW)

        # Top most sizer has to be set
        self.SetSizerAndFit(box_sizer)

        self.Canvas.SetMode(self.Modes[0][1])

    # REMOVE LATER, MOVE FUNCTIONALITY TO RIBBON TOOLBAR

    def BuildToolbar(self):
        """
        This is here so it can be over-ridden in a ssubclass, to add extra tools, etc
        """
        tb = wx.ToolBar(self)
        self.ToolBar = tb

        tb.SetToolBitmapSize((24, 24))
        self.AddToolbarModeButtons(tb, self.Modes)
        self.AddToolbarZoomButton(tb)
        tb.Realize()

    def AddToolbarModeButtons(self, tb, Modes):
        self.ModesDict = {}
        for Mode in Modes:
            tool = tb.AddRadioTool(wx.ID_ANY, shortHelp=Mode[0], bitmap=Mode[2])
            self.Bind(wx.EVT_TOOL, self.SetMode, tool)
            self.ModesDict[tool.GetId()]=Mode[1]
        #self.ZoomOutTool = tb.AddRadioTool(wx.ID_ANY, bitmap=Resources.getMagMinusBitmap(), shortHelp = "Zoom Out")
        #self.Bind(wx.EVT_TOOL, lambda evt : self.SetMode(Mode=self.GUIZoomOut), self.ZoomOutTool)

    def AddToolbarZoomButton(self, tb):
        tb.AddSeparator()

        self.ZoomButton = wx.Button(tb, label="Zoom To Fit")
        tb.AddControl(self.ZoomButton)
        self.ZoomButton.Bind(wx.EVT_BUTTON, self.ZoomToFit)


    def HideShowHack(self):
        ##fixme: remove this when the bug is fixed!
        """
        Hack to hide and show button on toolbar to get around OS-X bug on
        wxPython2.8 on OS-X
        """
        self.ZoomButton.Hide()
        self.ZoomButton.Show()

    def SetMode(self, event):
        Mode = self.ModesDict[event.GetId()]
        self.Canvas.SetMode(Mode)

    def ZoomToFit(self,Event):
        self.Canvas.ZoomToBB()
        self.Canvas.SetFocus() # Otherwise the focus stays on the Button, and wheel events are lost.


    #####################################################################################################################


    ##LEFT CLICK EVENT HANDLER
    def onLeftDown(self, event):
        if self.firstClick is False:
            self.firstClick = True
            self.pos = self.getSnapPos(event.GetCoords())
            self.Canvas.AddCircle(self.pos, 10, LineWidth=1, LineColor='BLACK', FillColor='BLACK')
            self.node_pos_list.append(self.pos)
            print self.pos
        else:
            self.lines.append((self.pos, self.getSnapPos(event.GetCoords())))
            if len(self.lines) != 0:
                self.pos = self.getSnapPos(event.GetCoords())
                print self.pos
                self.node_pos_list.append(self.pos)
        event.Skip()

    def onKeyDown(self, event):
        self.counter += 1
        print self.counter
        key_code = event.GetKeyCode()
        if key_code == wx.WXK_ESCAPE:
            print 'the escape key was pressed'
            self.firstClick = False
        elif key_code == wx.WXK_TAB:
            print 'the tab key was pressed'
            # if not self.Lines:
            #     return
            # else:
            #     self.lines.pop()

        #elif key_code == wx.WXK_ALT:

    ##POSSIBLY DEPRECIATED
    def getSnapPos(self, arg_pos):
        return (grid_cell_size* round(arg_pos[0]/grid_cell_size), grid_cell_size*round(arg_pos[1]/grid_cell_size))

    def onMouseMove(self,event):
        if event.Moving() and self.firstClick:
            self.drawMotion(event)
        event.Skip()


    def drawMotion(self, event):
        self.newPos = self.getSnapPos(event.GetCoords())
        coords = (self.pos , self.newPos)
        print coords
        # Optional method to add line to canvas
        # arrowline = FloatCanvas.SmoothArrowLine(coords, LineWidth=2, LineColor='BLUE', ArrowHeadSize=16)
        # self.Canvas.AddObject(arrowline)
        self.Canvas.AddSmoothArrowLine(coords, LineWidth=2, LineColor='BLUE', ArrowHeadSize=16)
        self.Canvas.Draw()
        self.Canvas.InitAll()
        for line in self.lines:
            # Optional method to add line to canvas
            # le_arrowline = FloatCanvas.SmoothArrowLine(line, LineWidth=2, LineColor='BLUE', ArrowHeadSize=16)
            # self.Canvas.AddObject(le_arrowline)
            self.Canvas.AddSmoothArrowLine(line, LineWidth=2, LineColor="RED", ArrowHeadSize=16)
        for nodes in self.node_pos_list:
            self.Canvas.AddCircle(nodes, 10, LineWidth=1, LineColor='BLACK', FillColor='BLACK')

    def onWheel(self, event):
        pass


##########################################################################
#################### GLOBAL###############################################
##########################################################################

SCREEN_HEIGHT = 640
SCREEN_WIDTH = 800
grid_cell_size = 30

##########################################################################
###############FRAME######################################################
##########################################################################

class WhereLeRibbonWillGo(wx.Frame):
    def __init__(self, parent, id, title, position, size):
        wx.Frame.__init__(self, parent, id, title, position, size)

        self.menubar = wx.MenuBar()
        self.fileMenu = wx.Menu()
        self.fitem = self.fileMenu.Append(wx.ID_EXIT, 'Quit', 'Quit application')
        self.menubar.Append(self.fileMenu, '&File')

        self.Bind(wx.EVT_MENU, self.OnQuit,  self.fitem)

        self.SetMenuBar(self.menubar)
        self.SetSize((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.SetTitle('Owen and Ian in love in the USA')
        self.DrawingPanel = DrawTheTrueTrue(self)
        self.Centre()
        self.Show()

    def OnQuit(self, event):
        self.Close()

def main():

    ex = wx.App()
    WhereLeRibbonWillGo(None, wx.ID_ANY, "Le Drawing Panel", None, None)
    ex.MainLoop()


if __name__ == '__main__':
    main()
